<?php
namespace Prism\PrismToken1;

/**
 * Autogenerated by Thrift Compiler (0.18.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;

class TokenApiClient implements \Prism\PrismToken1\TokenApiIf
{
    protected $input_ = null;
    protected $output_ = null;

    protected $seqid_ = 0;

    public function __construct($input, $output = null)
    {
        $this->input_ = $input;
        $this->output_ = $output ? $output : $input;
    }


    public function ping($sleepMs, $echo)
    {
        $this->send_ping($sleepMs, $echo);
        return $this->recv_ping();
    }

    public function send_ping($sleepMs, $echo)
    {
        $args = new \Prism\PrismToken1\TokenApi_ping_args();
        $args->sleepMs = $sleepMs;
        $args->echo = $echo;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'ping',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('ping', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_ping()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\Prism\PrismToken1\TokenApi_ping_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \Prism\PrismToken1\TokenApi_ping_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->ex1 !== null) {
            throw $result->ex1;
        }
        throw new \Exception("ping failed: unknown result");
    }

    public function signInWithPassword($messageId, $realm, $username, $password, \Prism\PrismToken1\SessionOptions $sessionOpts)
    {
        $this->send_signInWithPassword($messageId, $realm, $username, $password, $sessionOpts);
        return $this->recv_signInWithPassword();
    }

    public function send_signInWithPassword($messageId, $realm, $username, $password, \Prism\PrismToken1\SessionOptions $sessionOpts)
    {
        $args = new \Prism\PrismToken1\TokenApi_signInWithPassword_args();
        $args->messageId = $messageId;
        $args->realm = $realm;
        $args->username = $username;
        $args->password = $password;
        $args->sessionOpts = $sessionOpts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'signInWithPassword',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('signInWithPassword', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_signInWithPassword()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\Prism\PrismToken1\TokenApi_signInWithPassword_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \Prism\PrismToken1\TokenApi_signInWithPassword_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->ex1 !== null) {
            throw $result->ex1;
        }
        throw new \Exception("signInWithPassword failed: unknown result");
    }

    public function getStatus($messageId, $accessToken)
    {
        $this->send_getStatus($messageId, $accessToken);
        return $this->recv_getStatus();
    }

    public function send_getStatus($messageId, $accessToken)
    {
        $args = new \Prism\PrismToken1\TokenApi_getStatus_args();
        $args->messageId = $messageId;
        $args->accessToken = $accessToken;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'getStatus',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('getStatus', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_getStatus()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\Prism\PrismToken1\TokenApi_getStatus_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \Prism\PrismToken1\TokenApi_getStatus_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->ex1 !== null) {
            throw $result->ex1;
        }
        throw new \Exception("getStatus failed: unknown result");
    }

    public function parseIdRecord($messageId, $accessToken, $idRecord)
    {
        $this->send_parseIdRecord($messageId, $accessToken, $idRecord);
        return $this->recv_parseIdRecord();
    }

    public function send_parseIdRecord($messageId, $accessToken, $idRecord)
    {
        $args = new \Prism\PrismToken1\TokenApi_parseIdRecord_args();
        $args->messageId = $messageId;
        $args->accessToken = $accessToken;
        $args->idRecord = $idRecord;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'parseIdRecord',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('parseIdRecord', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_parseIdRecord()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\Prism\PrismToken1\TokenApi_parseIdRecord_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \Prism\PrismToken1\TokenApi_parseIdRecord_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->ex1 !== null) {
            throw $result->ex1;
        }
        throw new \Exception("parseIdRecord failed: unknown result");
    }

    public function loadTransactionLicense($messageId, $accessToken, $licenseText)
    {
        $this->send_loadTransactionLicense($messageId, $accessToken, $licenseText);
        return $this->recv_loadTransactionLicense();
    }

    public function send_loadTransactionLicense($messageId, $accessToken, $licenseText)
    {
        $args = new \Prism\PrismToken1\TokenApi_loadTransactionLicense_args();
        $args->messageId = $messageId;
        $args->accessToken = $accessToken;
        $args->licenseText = $licenseText;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'loadTransactionLicense',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('loadTransactionLicense', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_loadTransactionLicense()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\Prism\PrismToken1\TokenApi_loadTransactionLicense_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \Prism\PrismToken1\TokenApi_loadTransactionLicense_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->ex1 !== null) {
            throw $result->ex1;
        }
        throw new \Exception("loadTransactionLicense failed: unknown result");
    }

    public function issueCreditToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $subclass, $transferAmount, $tokenTime, $flags)
    {
        $this->send_issueCreditToken($messageId, $accessToken, $meterConfig, $subclass, $transferAmount, $tokenTime, $flags);
        return $this->recv_issueCreditToken();
    }

    public function send_issueCreditToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $subclass, $transferAmount, $tokenTime, $flags)
    {
        $args = new \Prism\PrismToken1\TokenApi_issueCreditToken_args();
        $args->messageId = $messageId;
        $args->accessToken = $accessToken;
        $args->meterConfig = $meterConfig;
        $args->subclass = $subclass;
        $args->transferAmount = $transferAmount;
        $args->tokenTime = $tokenTime;
        $args->flags = $flags;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'issueCreditToken',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('issueCreditToken', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_issueCreditToken()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\Prism\PrismToken1\TokenApi_issueCreditToken_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \Prism\PrismToken1\TokenApi_issueCreditToken_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->ex1 !== null) {
            throw $result->ex1;
        }
        throw new \Exception("issueCreditToken failed: unknown result");
    }

    public function issueMeterTestToken($messageId, $accessToken, $subclass, $control, $mfrcode)
    {
        $this->send_issueMeterTestToken($messageId, $accessToken, $subclass, $control, $mfrcode);
        return $this->recv_issueMeterTestToken();
    }

    public function send_issueMeterTestToken($messageId, $accessToken, $subclass, $control, $mfrcode)
    {
        $args = new \Prism\PrismToken1\TokenApi_issueMeterTestToken_args();
        $args->messageId = $messageId;
        $args->accessToken = $accessToken;
        $args->subclass = $subclass;
        $args->control = $control;
        $args->mfrcode = $mfrcode;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'issueMeterTestToken',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('issueMeterTestToken', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_issueMeterTestToken()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\Prism\PrismToken1\TokenApi_issueMeterTestToken_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \Prism\PrismToken1\TokenApi_issueMeterTestToken_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->ex1 !== null) {
            throw $result->ex1;
        }
        throw new \Exception("issueMeterTestToken failed: unknown result");
    }

    public function issueMseToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $subclass, $transferAmount, $tokenTime, $flags)
    {
        $this->send_issueMseToken($messageId, $accessToken, $meterConfig, $subclass, $transferAmount, $tokenTime, $flags);
        return $this->recv_issueMseToken();
    }

    public function send_issueMseToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $subclass, $transferAmount, $tokenTime, $flags)
    {
        $args = new \Prism\PrismToken1\TokenApi_issueMseToken_args();
        $args->messageId = $messageId;
        $args->accessToken = $accessToken;
        $args->meterConfig = $meterConfig;
        $args->subclass = $subclass;
        $args->transferAmount = $transferAmount;
        $args->tokenTime = $tokenTime;
        $args->flags = $flags;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'issueMseToken',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('issueMseToken', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_issueMseToken()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\Prism\PrismToken1\TokenApi_issueMseToken_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \Prism\PrismToken1\TokenApi_issueMseToken_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->ex1 !== null) {
            throw $result->ex1;
        }
        throw new \Exception("issueMseToken failed: unknown result");
    }

    public function issueSetControlToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $isFlag, $index, $value, $tokenTime, $flags)
    {
        $this->send_issueSetControlToken($messageId, $accessToken, $meterConfig, $isFlag, $index, $value, $tokenTime, $flags);
        return $this->recv_issueSetControlToken();
    }

    public function send_issueSetControlToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $isFlag, $index, $value, $tokenTime, $flags)
    {
        $args = new \Prism\PrismToken1\TokenApi_issueSetControlToken_args();
        $args->messageId = $messageId;
        $args->accessToken = $accessToken;
        $args->meterConfig = $meterConfig;
        $args->isFlag = $isFlag;
        $args->index = $index;
        $args->value = $value;
        $args->tokenTime = $tokenTime;
        $args->flags = $flags;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'issueSetControlToken',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('issueSetControlToken', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_issueSetControlToken()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\Prism\PrismToken1\TokenApi_issueSetControlToken_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \Prism\PrismToken1\TokenApi_issueSetControlToken_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->ex1 !== null) {
            throw $result->ex1;
        }
        throw new \Exception("issueSetControlToken failed: unknown result");
    }

    public function issueKeyChangeTokens($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, \Prism\PrismToken1\MeterConfigAmendment $newConfig)
    {
        $this->send_issueKeyChangeTokens($messageId, $accessToken, $meterConfig, $newConfig);
        return $this->recv_issueKeyChangeTokens();
    }

    public function send_issueKeyChangeTokens($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, \Prism\PrismToken1\MeterConfigAmendment $newConfig)
    {
        $args = new \Prism\PrismToken1\TokenApi_issueKeyChangeTokens_args();
        $args->messageId = $messageId;
        $args->accessToken = $accessToken;
        $args->meterConfig = $meterConfig;
        $args->newConfig = $newConfig;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'issueKeyChangeTokens',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('issueKeyChangeTokens', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_issueKeyChangeTokens()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\Prism\PrismToken1\TokenApi_issueKeyChangeTokens_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \Prism\PrismToken1\TokenApi_issueKeyChangeTokens_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->ex1 !== null) {
            throw $result->ex1;
        }
        throw new \Exception("issueKeyChangeTokens failed: unknown result");
    }

    public function verifyToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $tokenDec)
    {
        $this->send_verifyToken($messageId, $accessToken, $meterConfig, $tokenDec);
        return $this->recv_verifyToken();
    }

    public function send_verifyToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $tokenDec)
    {
        $args = new \Prism\PrismToken1\TokenApi_verifyToken_args();
        $args->messageId = $messageId;
        $args->accessToken = $accessToken;
        $args->meterConfig = $meterConfig;
        $args->tokenDec = $tokenDec;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'verifyToken',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('verifyToken', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_verifyToken()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\Prism\PrismToken1\TokenApi_verifyToken_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \Prism\PrismToken1\TokenApi_verifyToken_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->ex1 !== null) {
            throw $result->ex1;
        }
        throw new \Exception("verifyToken failed: unknown result");
    }

    public function issueDitkChangeTokens($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig)
    {
        $this->send_issueDitkChangeTokens($messageId, $accessToken, $meterConfig);
        return $this->recv_issueDitkChangeTokens();
    }

    public function send_issueDitkChangeTokens($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig)
    {
        $args = new \Prism\PrismToken1\TokenApi_issueDitkChangeTokens_args();
        $args->messageId = $messageId;
        $args->accessToken = $accessToken;
        $args->meterConfig = $meterConfig;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'issueDitkChangeTokens',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('issueDitkChangeTokens', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_issueDitkChangeTokens()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\Prism\PrismToken1\TokenApi_issueDitkChangeTokens_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \Prism\PrismToken1\TokenApi_issueDitkChangeTokens_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->ex1 !== null) {
            throw $result->ex1;
        }
        throw new \Exception("issueDitkChangeTokens failed: unknown result");
    }

    public function fetchTokenResult($messageId, $accessToken, $reqMessageId)
    {
        $this->send_fetchTokenResult($messageId, $accessToken, $reqMessageId);
        return $this->recv_fetchTokenResult();
    }

    public function send_fetchTokenResult($messageId, $accessToken, $reqMessageId)
    {
        $args = new \Prism\PrismToken1\TokenApi_fetchTokenResult_args();
        $args->messageId = $messageId;
        $args->accessToken = $accessToken;
        $args->reqMessageId = $reqMessageId;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'fetchTokenResult',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('fetchTokenResult', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_fetchTokenResult()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\Prism\PrismToken1\TokenApi_fetchTokenResult_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \Prism\PrismToken1\TokenApi_fetchTokenResult_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->ex1 !== null) {
            throw $result->ex1;
        }
        throw new \Exception("fetchTokenResult failed: unknown result");
    }

    public function ctsResetTidList($messageId, $accessToken, $panPattern)
    {
        $this->send_ctsResetTidList($messageId, $accessToken, $panPattern);
        return $this->recv_ctsResetTidList();
    }

    public function send_ctsResetTidList($messageId, $accessToken, $panPattern)
    {
        $args = new \Prism\PrismToken1\TokenApi_ctsResetTidList_args();
        $args->messageId = $messageId;
        $args->accessToken = $accessToken;
        $args->panPattern = $panPattern;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'ctsResetTidList',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('ctsResetTidList', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_ctsResetTidList()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\Prism\PrismToken1\TokenApi_ctsResetTidList_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \Prism\PrismToken1\TokenApi_ctsResetTidList_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->ex1 !== null) {
            throw $result->ex1;
        }
        throw new \Exception("ctsResetTidList failed: unknown result");
    }
}
